# Specifications for the Rails Assessment

Specs:
- [x] Using Ruby on Rails for the project
- [x] Include at least one has_many relationship (x has_many y; e.g. User has_many Recipes) Each author instance has many books (ie, each author instance can be associated with many book instances, and many book instances can belong to the same author).
- [x] Include at least one belongs_to relationship (x belongs_to y; e.g. Post belongs_to User) Each list instance belongs to a user (ie, a user has many lists and each list belongs to a particular user). There is a  foreign id column, user_id, in the lists table. 
- [x] Include at least two has_many through relationships (x has_many y through z; e.g. Recipe has_many Items through Ingredients) Lists have many books through listings; users have many listed books through lists and listings. Additionally, books have many readers through read_books.
- [x] Include at least one many-to-many relationship (x has_many y through z, y has_many x through z; e.g. Recipe has_many Items through Ingredients, Item has_many Recipes through Ingredients) Users have many books through a join table, read_books, and books have many readers through the same join table. In other words, each read_book associates one book with one user, which means that a book can be associated with many users (readers) and a user can be associated with many books.
- [x] The "through" part of the has_many through includes at least one user submittable attribute, that is to say, some attribute other than its foreign keys that can be submitted by the app's user (attribute_name e.g. ingredients.quantity) The join table read_books stores data about when each user read each book. Whenever a user says that they read a book (essentially creating a read_book object), they must record when they read that book. That data is then stored in the .date_read attribute of the new read_book object.
- [x] Include reasonable validations for simple model objects (list of model objects with validations e.g. User, Recipe, Ingredient, Item) Each of my models has at least one validation. For example, read_book validates uniqueness of user and reader, so that a reader cannot read the same book twice. The user model validates uniqueness and presence of username, so that the application does not confuse two users with the same username. Book validates the presence of a title and author, and the uniqueness of title and author so the same book cannot be created twice.
- [x] Include a class level ActiveRecord scope method (model object & class method name and URL to see the working feature e.g. User.most_recipes URL: /users/most_recipes) My Book model has a method that retrieves all of the current user's read books (using the "where" method) and all of the books the current user read this year (by selecting the current user's books, then joining the read_books table and selecting all books read after the beginning of the year).
- [x] Include signup (how e.g. Devise) My application has a sign up page which saves a new user instance to the database and automatically logs that user in.
- [x] Include login (how e.g. Devise) My application includes a login page which adds the user's id to the session hash.
- [x] Include logout (how e.g. Devise) My application includes a logout button in the navigation bar which deletes the user id from the session.
- [x] Include third party signup/login (how e.g. Devise/OmniAuth) My application includes a link to login with facebook on the login page, which creates a new user with omniauth data received from Facebook (then automatically logs that user in with a random password).
- [x] Include nested resource show or index (URL e.g. users/2/recipes) Users can create a new book written by an author with a given id at the url authors/(author_id)/books/new. Users can also see all the books written by a given author at authors/(author_id)/books.
- [x] Include nested resource "new" form (URL e.g. recipes/1/ingredients/new) See above
- [x] Include form display of validation errors (form URL e.g. /recipes/new) The forms which create and edit authors, books, and lists all re-render to show validation errors if the user fills in the fields incorrectly. The forms also surround the incorrect fields with a field_with_errors div. When the user is creating something less explicitly (ie, creating a read_book object by affirming they read a given book) I display validation errors using flash messages, but do not re-render the page (because, in this case, there are very few ways a user could create an invalid object - if this happens it is more likely the result of hacking or a bug).

Confirm:
- [x] The application is pretty DRY Whenever I realized I was typing the same logic into the controller three or more times, I put the logic into a class method or a private method I could call from the controller. I created methods for tasks such as finding an instance using an id parameter, finding the current user of the application, and making flash messages from errors.
- [x] Limited logic in controllers See above - whenever I needed to get data from a model, I used a class method which I called from the controller.
- [x] Views use helper methods if appropriate I only used two helper methods inside my views, for two reasons: a) I could only find one piece of logic I reuse in multiple templates and I had not already placed in a partial. b) Almost all the logic included in my views contained multiple content tags within 'each' statements, and I do not know how to write ruby code to render content tags. 
- [x] Views use partials if appropriate Whenever I used a long block of code (> 4 lines) in more than one template, I put the form into a partial. Partials include forms for creating and editting new books and lists, a block of code that displays errors, and a block of (mostly HTML) code that displays the nav bar.